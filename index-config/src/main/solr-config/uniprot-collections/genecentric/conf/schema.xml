<?xml version="1.0" encoding="UTF-8" ?>

<schema name="genecentric" version="1.6">
	<!-- attribute "name" is the name of this schema and is only used for display 
		purposes. version="x.y" is Solr's version number for the schema syntax and 
		semantics. It should not normally be changed by applications. 1.0: multiValued 
		attribute did not exist, all fields are multiValued by nature 1.1: multiValued 
		attribute introduced, false by default 1.2: omitTermFreqAndPositions attribute 
		introduced, true by default except for text fields. 1.3: removed optional 
		field compress feature 1.4: autoGeneratePhraseQueries attribute introduced 
		to drive QueryParser behavior when a single string produces multiple tokens. 
		Defaults to off for version >= 1.4 1.5: omitNorms defaults to true for primitive 
		field types (int, float, boolean, string...) -->


	<!-- Valid attributes for fields: name: mandatory - the name for the field 
		type: mandatory - the name of a field type from the <types> fieldType section 
		indexed: true if this field should be indexed (searchable or sortable) stored: 
		true if this field should be retrievable docValues: true if this field should 
		have doc values. Doc values are useful for faceting, grouping, sorting and 
		function queries. Although not required, doc values will make the index faster 
		to load, more NRT-friendly and more memory-efficient. They however come with 
		some limitations: they are currently only supported by StrField, UUIDField 
		and all Trie*Fields, and depending on the field type, they might require 
		the field to be single-valued, be required or have a default value (check 
		the documentation of the field type you're interested in for more information) 
		multiValued: true if this field may contain multiple values per document 
		omitNorms: (expert) set to true to omit the norms associated with this field 
		(this disables length normalization and index-time boosting for the field, 
		and saves some memory). Only full-text fields or fields that need an index-time 
		boost need norms. Norms are omitted for primitive (non-analyzed) types by 
		default. termVectors: [false] set to true to store the term vector for a 
		given field. When using MoreLikeThis, fields used for similarity should be 
		stored for best performance. termPositions: Store position information with 
		the term vector. This will increase storage costs. termOffsets: Store offset 
		information with the term vector. This will increase storage costs. required: 
		The field is required. It will throw an error if the value does not exist 
		default: a value that should be used if no value is specified when adding 
		a document. -->

	<!-- field names should consist of alphanumeric or underscore characters 
		only and not start with a digit. This is not currently strictly enforced, 
		but other field names will not have first class support from all components 
		and back compatibility is not guaranteed. Names with both leading and trailing 
		underscores (e.g. _version_) are reserved. -->

	<!-- If you remove this field, you must _also_ disable the update log in 
		solrconfig.xml or Solr won't start. _version_ and update log are required 
		for SolrCloud -->
	<field name="_version_" type="plong" indexed="true" stored="true" />

	<!-- points to the root document of a block of nested documents. Required 
		for nested document support, may be removed otherwise -->
	<field name="_root_" type="string" indexed="true" stored="false" />

	<!-- Dynamic field definitions allow using convention over configuration 
		for fields via the specification of patterns to match field names. EXAMPLE: 
		name="*_i" will match any field ending in _i (like myid_i, z_i) RESTRICTION: 
		the glob-like pattern in the name attribute must have a "*" only at the start 
		or the end. -->



	<dynamicField name="ignored_*" type="ignored"
		multiValued="true" />
	<dynamicField name="attr_*" type="text_general"
		indexed="true" stored="true" multiValued="true" />

	<dynamicField name="random_*" type="random" />

	<!-- A general text field that has reasonable, generic cross-language defaults: 
		it tokenizes with StandardTokenizer, removes stop words from case-insensitive 
		"stopwords.txt" (empty by default), and down cases. At query time only, it 
		also applies synonyms. -->
	<fieldType name="text_general" class="solr.TextField"
		positionIncrementGap="100">
		<analyzer type="index">
			<tokenizer class="solr.StandardTokenizerFactory" />
			<filter class="solr.StopFilterFactory" ignoreCase="true"
				words="stopwords.txt" />
			<!-- in this example, we will only use synonyms at query time <filter 
				class="solr.SynonymGraphFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" 
				expand="false"/> <filter class="solr.FlattenGraphFilterFactory"/> -->
			<filter class="solr.LowerCaseFilterFactory" />
		</analyzer>
		<analyzer type="query">
			<tokenizer class="solr.StandardTokenizerFactory" />
			<filter class="solr.StopFilterFactory" ignoreCase="true"
				words="stopwords.txt" />
			<filter class="solr.SynonymGraphFilterFactory"
				synonyms="synonyms.txt" ignoreCase="true" expand="true" />
			<filter class="solr.LowerCaseFilterFactory" />
		</analyzer>
	</fieldType>
	<!-- uncomment the following to ignore any fields that don't already match 
		an existing field name or dynamic field, rather than reporting them as an 
		error. alternately, change the type="ignored" to some other type e.g. "text" 
		if you want unknown fields indexed and/or stored by default -->
	<!--dynamicField name="*" type="ignored" multiValued="true" / -->

	<!-- Field to use to determine and enforce document uniqueness. Unless this 
		field is marked with required="false", it will be a required field -->
	<uniqueKey>accession_id</uniqueKey>

	<!-- copyField commands copy one field to another at the time a document 
		is added to the index. It's used either to index the same field differently, 
		or to add multiple fields to the same field for easier/faster searching. -->

	<!-- <copyField source="title" dest="text"/> <copyField source="body" dest="text"/> -->

	<!-- field type definitions. The "name" attribute is just a label to be 
		used by field definitions. The "class" attribute and any other attributes 
		determine the real behavior of the fieldType. Class names starting with "solr" 
		refer to java classes in a standard package such as org.apache.solr.analysis -->

	<!-- The StrField type is not analyzed, but indexed/stored verbatim. It 
		supports doc values but in that case the field needs to be single-valued 
		and either required or have a default value. -->
	<fieldType name="string" class="solr.StrField"
		sortMissingLast="true" />

	<!-- boolean type: "true" or "false" -->
	<fieldType name="boolean" class="solr.BoolField"
		sortMissingLast="true" />

	<fieldType name="int" class="solr.IntPointField"
		docValues="true" />
	<fieldType name="float" class="solr.FloatPointField"
		docValues="true" />
	<fieldType name="long" class="solr.LongPointField"
		docValues="true" />
	<fieldType name="double" class="solr.DoublePointField"
		docValues="true" />

	<fieldType name="pint" class="solr.IntPointField"
		docValues="true" />
	<fieldType name="pfloat" class="solr.FloatPointField"
		docValues="true" />
	<fieldType name="plong" class="solr.LongPointField"
		docValues="true" />
	<fieldType name="pdouble" class="solr.DoublePointField"
		docValues="true" />

	<fieldType name="pints" class="solr.IntPointField"
		docValues="true" multiValued="true" />
	<fieldType name="pfloats" class="solr.FloatPointField"
		docValues="true" multiValued="true" />
	<fieldType name="plongs" class="solr.LongPointField"
		docValues="true" multiValued="true" />
	<fieldType name="pdoubles" class="solr.DoublePointField"
		docValues="true" multiValued="true" />

	<fieldType name="pdate" class="solr.DatePointField"
		docValues="true" />
	<fieldType name="pdates" class="solr.DatePointField"
		docValues="true" multiValued="true" />
	<fieldType name="date" class="solr.DatePointField"
		docValues="true" />

	<!-- sortMissingLast and sortMissingFirst attributes are optional attributes 
		are currently supported on types that are sorted internally as strings and 
		on numeric types. This includes "string","boolean", and, as of 3.5 (and 4.x), 
		int, float, long, date, double, including the "Trie" variants. - If sortMissingLast="true", 
		then a sort on this field will cause documents without the field to come 
		after documents with the field, regardless of the requested sort order (asc 
		or desc). - If sortMissingFirst="true", then a sort on this field will cause 
		documents without the field to come before documents with the field, regardless 
		of the requested sort order. - If sortMissingLast="false" and sortMissingFirst="false" 
		(the default), then default lucene sorting will be used which places docs 
		without the field first in an ascending sort and last in a descending sort. -->

	<!-- Default numeric field types. For faster range queries, consider the 
		tint/tfloat/tlong/tdouble types. These fields support doc values, but they 
		require the field to be single-valued and either be required or have a default 
		value. -->

	<!--Binary data type. The data should be sent/retrieved in as Base64 encoded 
		Strings -->
	<fieldType name="binary" class="solr.BinaryField" />

	<!-- The "RandomSortField" is not used to store or search any data. You 
		can declare fields of this type it in your schema to generate pseudo-random 
		orderings of your docs for sorting or function purposes. The ordering is 
		generated based on the field name and the version of the index. As long as 
		the index version remains unchanged, and the same field name is reused, the 
		ordering of the docs will be consistent. If you want different psuedo-random 
		orderings of documents, for the same version of the index, use a dynamicField 
		and change the field name in the request. -->
	<fieldType name="random" class="solr.RandomSortField"
		indexed="true" />

	<!-- solr.TextField allows the specification of custom text analyzers specified 
		as a tokenizer and a list of token filters. Different analyzers may be specified 
		for indexing and querying. The optional positionIncrementGap puts space between 
		multiple fields of this type on the same document, with the purpose of preventing 
		false phrase matching across fields. For more info on customizing your analyzer 
		chain, please see http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters -->

	<!-- One can also specify an existing Analyzer class that has a default 
		constructor via the class attribute on the analyzer element. Example: <fieldType 
		name="text_greek" class="solr.TextField"> <analyzer class="org.apache.lucene.analysis.el.GreekAnalyzer"/> 
		</fieldType> -->

	<!-- basic analysis for fields that require no splitting -->
	<fieldType name="basic_ci" class="solr.TextField"
		sortMissingLast="true" omitNorms="true" positionIncrementGap="100">
		<analyzer type="index">
			<tokenizer class="solr.WhitespaceTokenizerFactory" />
			<filter class="solr.LowerCaseFilterFactory" />
		</analyzer>
		<analyzer type="query">
			<tokenizer class="solr.WhitespaceTokenizerFactory" />
			<filter class="solr.LowerCaseFilterFactory" />
		</analyzer>
	</fieldType>

	<!-- since fields of this type are by default not stored or indexed, any 
		data added to them will be ignored outright. -->
	<fieldType name="ignored" stored="false" indexed="false"
		multiValued="true" class="solr.StrField" />

	<!-- Example of using PathHierarchyTokenizerFactory at index time, so queries 
		for paths match documents at that path, or in descendent paths -->


	<fieldType name="full_ci" class="solr.TextField"
		sortMissingLast="true" omitNorms="true" positionIncrementGap="100">
		<analyzer type="index">
			<tokenizer class="solr.WhitespaceTokenizerFactory" />
			<filter class="solr.ASCIIFoldingFilterFactory"
				preserveOriginal="false" />
			<filter class="solr.WordDelimiterGraphFilterFactory"
				generateWordParts="1" generateNumberParts="1" catenateWords="1"
				catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"
				preserveOriginal="1" splitOnNumerics="1" stemEnglishPossessive="1" />
			<filter class="solr.FlattenGraphFilterFactory" />
			<filter class="solr.LowerCaseFilterFactory" />
		</analyzer>
		<analyzer type="query">
			<tokenizer class="solr.WhitespaceTokenizerFactory" />
			<filter class="solr.ASCIIFoldingFilterFactory"
				preserveOriginal="false" />
			<filter class="solr.WordDelimiterGraphFilterFactory"
				generateWordParts="1" generateNumberParts="1" catenateWords="1"
				catenateNumbers="1" catenateAll="1" splitOnCaseChange="1"
				preserveOriginal="1" splitOnNumerics="1" stemEnglishPossessive="1" />
			<filter class="solr.LowerCaseFilterFactory" />
		</analyzer>
	</fieldType>

	<!-- ====================================================================================== -->
	<!-- =============================== genecentric configurations =============================== -->
	<!-- ====================================================================================== -->
	<field name="accession_id" type="string" indexed="true"
		stored="true" required="true" multiValued="false" />
	<field name="accession" type="basic_ci" indexed="true"
		stored="false" required="true" multiValued="true" />
	<field name="upid" type="basic_ci" indexed="true" stored="false"
		required="true" multiValued="false" />
	<field name="reviewed" type="boolean" indexed="true"
		stored="false" required="false" multiValued="false" />
	<field name="organism_id" type="int" indexed="true"
		stored="false" required="false" multiValued="false" />
	<field name="gene" type="full_ci" indexed="true" stored="false"
		required="false" multiValued="true" />
	<field name="genecentric_stored" type="binary" indexed="false"
		stored="true" required="true" multiValued="false" />
	<field name="content" type="full_ci" indexed="true"
		stored="false" multiValued="true" />
	<copyField source="accession" dest="content" />
	<copyField source="upid" dest="content" />
	<copyField source="organism_id" dest="content" />
	<copyField source="gene" dest="content" />
</schema>